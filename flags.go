package main

import (
	"flag"
	"fmt"
	"slices"
)

type flags struct {
	flac    string
	bitrate int
	mp3     string
	volume  int
}

func getNearestBitrate(bitrate int) int {
	availableBitrates := []int{8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320}
	if !slices.Contains(availableBitrates, bitrate) {
		bitrate = getNearest(bitrate, availableBitrates)
		fmt.Printf("Bitrate unavailable. Using nearest available bitrate of %dkbps.\n", bitrate)
	}
	return bitrate
}

func NewFlags() (*flags, error) {
	flac := flag.String("flac", "", "REQUIRED - Path to the input FLAC file")
	bitrate := flag.Int("bitrate", 128, "Constant bitrate of the temporary MP3 file, measured in kbps. It can be 8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256 or 320") // https://trac.ffmpeg.org/wiki/Encode/MP3#CBREncoding
	mp3 := flag.String("mp3", "", "Path to an input MP3 file (default \"\", an MP3 file will be temporarily generated by compressing the FLAC file)")
	volume := flag.Int("volume", 50, "Initial volume %% used for audio playback")

	flag.Parse()

	if *flac == "" {
		return nil, fmt.Errorf("Error: Required flag missing.")
	}

	if flacExists, err := exists(*flac); !flacExists {
		return nil, fmt.Errorf("Error: FLAC file not found:\n\t%s", err.Error())
	}

	if mp3Exists, err := exists(*mp3); *mp3 != "" && !mp3Exists {
		return nil, fmt.Errorf("Error: MP3 file not found:\n\t%s", err.Error())
	}

	*bitrate = getNearestBitrate(*bitrate)

	if *volume < 0 || *volume > 100 {
		*volume = clamp(*volume, 0, 100)
		fmt.Printf("Volume clamped to %d%%.\n", *volume)
	}

	return &flags{
		flac:    *flac,
		bitrate: *bitrate,
		mp3:     *mp3,
		volume:  *volume,
	}, nil
}

func (f flags) Flac() string {
	return f.flac
}

func (f flags) Bitrate() int {
	return f.bitrate
}

func (f flags) Mp3() string {
	return f.mp3
}

func (f flags) Volume() int {
	return f.volume
}
