package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

type flags struct {
	flac    string
	bitrate int
	mp3     string
	volume  int
	history string
	summary bool
}

func getNearestBitrate(bitrate int) int {
	availableBitrates := []int{8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320}
	if !slices.Contains(availableBitrates, bitrate) {
		bitrate = getNearest(bitrate, availableBitrates)
		fmt.Printf("Bitrate unavailable. Using nearest available bitrate of %dkbps.\n", bitrate)
	}
	return bitrate
}

func NewFlags() (*flags, error) {
	flac := flag.String("flac", "", "Path to the input FLAC file. This argument is REQUIRED unless the summary flag is provided")
	bitrate := flag.Int("bitrate", 128, "Constant bitrate of the temporary MP3 file, measured in kbps. It can be 8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256 or 320") // https://trac.ffmpeg.org/wiki/Encode/MP3#CBREncoding
	mp3 := flag.String("mp3", "", "Path to an input MP3 file (default \"\", an MP3 file will be temporarily generated by compressing the FLAC file)")
	volume := flag.Int("volume", 50, "Initial volume %% used for audio playback")
	history := flag.String("history", "", "Path to the CSV file that stores the history of previous results. The results of the current execution will be appended to this file. If the provided path does not exist, a new CSV file will be created. This argument is REQUIRED if the summary flag is provided (default \"\", no summary will be displayed and the results of the current execution won't be stored)")
	summary := flag.Bool("summary", false, "If provided, the program will exit immediately after showing a statistical summary of previous attempts")

	flag.Parse()

	if !*summary && *flac == "" {
		return nil, fmt.Errorf("Error: FLAC file not provided.")
	}

	if *summary && *history == "" {
		return nil, fmt.Errorf("Error: Previous history CSV file not provided.")
	}

	if flacExists, err := exists(*flac); *flac != "" && !flacExists {
		return nil, fmt.Errorf("Error: FLAC file not found:\n\t%s", err.Error())
	}

	if mp3Exists, err := exists(*mp3); *mp3 != "" && !mp3Exists {
		return nil, fmt.Errorf("Error: MP3 file not found:\n\t%s", err.Error())
	}

	if csvExists, _ := exists(*history); *history != "" && !csvExists {
		if filepath.Ext(*history) != ".csv" {
			return nil, fmt.Errorf("Error: Previous history file must have a .csv extension.")
		}
		file, err := os.Create(*history)
		if err != nil {
			return nil, fmt.Errorf("Error when creating CSV file %s:\n\t%s", *history, err.Error())
		}
		defer file.Close()
		_, err = file.WriteString(fmt.Sprintf("%s\n", strings.Join(ResultFields(), ",")))
		if err != nil {
			return nil, fmt.Errorf("Error when appending header to CSV file %s:\n\t%s", *history, err.Error())
		}
	} else if *history != "" && csvExists {
		if csvHeadersMatch, err := matchCSVHeader(*history, ResultFields()); err != nil {
			return nil, err
		} else if !csvHeadersMatch {
			return nil, fmt.Errorf("Error: Previous history CSV file headers do not match the expected headers (%s).", strings.Join(ResultFields(), ", "))
		}
	}

	*bitrate = getNearestBitrate(*bitrate)

	if *volume < 0 || *volume > 100 {
		*volume = clamp(*volume, 0, 100)
		fmt.Printf("Volume clamped to %d%%.\n", *volume)
	}

	return &flags{
		flac:    *flac,
		bitrate: *bitrate,
		mp3:     *mp3,
		volume:  *volume,
		history: *history,
		summary: *summary,
	}, nil
}

func (f flags) Flac() string {
	return f.flac
}

func (f flags) Bitrate() int {
	return f.bitrate
}

func (f flags) Mp3() string {
	return f.mp3
}

func (f flags) Volume() int {
	return f.volume
}

func (f flags) History() string {
	return f.history
}

func (f flags) Summary() bool {
	return f.summary
}
