package main

import (
	"flag"
	"fmt"
	"os"
	"slices"
)

type flags struct {
	flac    string
	bitrate int
	mp3     string
	volume  int
}

func NewFlags() *flags {
	flac := flag.String("flac", "", "REQUIRED - Path to the input FLAC file")
	bitrate := flag.Int("bitrate", 128, "Constant bitrate of the temporary MP3 file, measured in kbps. It can be 8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256 or 320") // https://trac.ffmpeg.org/wiki/Encode/MP3#CBREncoding
	mp3 := flag.String("mp3", "", "Path to an input MP3 file (default \"\", an MP3 file will be temporarily generated by compressing the FLAC file)")
	volume := flag.Int("volume", 50, "Initial volume %% used for audio playback")

	flag.Parse()

	if *flac == "" {
		fmt.Print("Error: Required flag missing.\n")
		flag.Usage()
		os.Exit(1)
	}

	if !exists(*flac) {
		fmt.Print("Error: FLAC file not found.\n")
		os.Exit(1)
	}

	if *mp3 != "" && !exists(*mp3) {
		fmt.Print("Error: MP3 file not found.\n")
		os.Exit(1)
	}

	availableBitrates := []int{8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320}
	if !slices.Contains(availableBitrates, *bitrate) {
		*bitrate = getNearest(*bitrate, availableBitrates)
		fmt.Printf("Bitrate unavailable. Using nearest available bitrate of %dkbps.\n", *bitrate)
	}

	if *volume < 0 || *volume > 100 {
		*volume = clamp(*volume, 0, 100)
		fmt.Printf("Volume clamped to %d%%.\n", *volume)
	}

	return &flags{
		flac:    *flac,
		bitrate: *bitrate,
		mp3:     *mp3,
		volume:  *volume,
	}
}

func (f flags) Flac() string {
	return f.flac
}

func (f flags) Bitrate() int {
	return f.bitrate
}

func (f flags) Mp3() string {
	return f.mp3
}

func (f flags) Volume() int {
	return f.volume
}
